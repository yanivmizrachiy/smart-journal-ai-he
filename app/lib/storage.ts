const DB_NAME='SJH_DB', STORE='entries', USE_IDB='indexedDB'in self; export type Entry={path:string;content:string;updated:number};
function openDB(){return new Promise<IDBDatabase>((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>{const db=r.result;if(!db.objectStoreNames.contains(STORE))db.createObjectStore(STORE,{keyPath:'path'})};r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error)})}
export async function save(path:string,content:string){const updated=Date.now(); if(USE_IDB){const db=await openDB(); await new Promise((res,rej)=>{const tx=db.transaction(STORE,'readwrite');tx.objectStore(STORE).put({path,content,updated});tx.oncomplete=()=>res(0);tx.onerror=()=>rej(tx.error)});db.close()} localStorage.setItem(`SJH:${path}`,JSON.stringify({content,updated})); localStorage.setItem('SJH:index',JSON.stringify(addToIndex(path))); return {ok:true,updated}}
export async function load(path:string){if(USE_IDB){try{const db=await openDB();const v=await new Promise<any>((res,rej)=>{const tx=db.transaction(STORE,'readonly');const g=tx.objectStore(STORE).get(path);g.onsuccess=()=>res(g.result||null);g.onerror=()=>rej(g.error)});db.close();if(v)return v}catch{}} const raw=localStorage.getItem(`SJH:${path}`);if(!raw)return null;const j=JSON.parse(raw);return {path,content:j.content,updated:j.updated}}
export function listPaths(){const idx=JSON.parse(localStorage.getItem('SJH:index')||'[]');return Array.from(new Set(idx)).sort()}
function addToIndex(path:string){const s=new Set(JSON.parse(localStorage.getItem('SJH:index')||'[]'));s.add(path);return Array.from(s)}
